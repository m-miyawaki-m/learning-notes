# 一般的なコンピュータサイエンス基礎概念目次

> ソフトウェアエンジニアとして知っておくべきCS基礎知識の体系的な目次

---

## 1. コンピュータサイエンス基礎

### 1.1 データ構造
- 1.1.1 配列とリスト
- 1.1.2 スタックとキュー
- 1.1.3 ツリー（二分木、B木、赤黒木）
- 1.1.4 ハッシュテーブル
- 1.1.5 グラフ
- 1.1.6 ヒープ

### 1.2 アルゴリズム
- 1.2.1 計算量（Big O記法）
- 1.2.2 ソートアルゴリズム
- 1.2.3 探索アルゴリズム（二分探索、DFS、BFS）
- 1.2.4 動的計画法
- 1.2.5 貪欲法
- 1.2.6 分割統治法

### 1.3 コンピュータアーキテクチャ
- 1.3.1 CPUの動作原理
- 1.3.2 メモリ階層（キャッシュ、RAM、ストレージ）
- 1.3.3 仮想メモリ
- 1.3.4 プロセスとスレッド

---

## 2. オペレーティングシステム

### 2.1 プロセス管理
- 2.1.1 プロセスとスレッドの違い
- 2.1.2 コンテキストスイッチ
- 2.1.3 スケジューリングアルゴリズム
- 2.1.4 マルチスレッディング

### 2.2 メモリ管理
- 2.2.1 仮想メモリとページング
- 2.2.2 メモリアロケーション
- 2.2.3 ガベージコレクション原理
- 2.2.4 メモリリークとその検出

### 2.3 並行処理/並列処理
- 2.3.1 並行 vs 並列
- 2.3.2 競合状態（Race Condition）
- 2.3.3 デッドロック
- 2.3.4 同期機構（Mutex、Semaphore、Monitor）
- 2.3.5 アトミック操作

---

## 3. ネットワーク基礎

### 3.1 ネットワーク層モデル
- 3.1.1 OSI 7層モデル
- 3.1.2 TCP/IPモデル
- 3.1.3 各層の役割と責務

### 3.2 プロトコル
- 3.2.1 TCP vs UDP
- 3.2.2 HTTP/HTTPS
- 3.2.3 DNS
- 3.2.4 WebSocket

### 3.3 ネットワークセキュリティ
- 3.3.1 暗号化（対称・非対称）
- 3.3.2 SSL/TLS
- 3.3.3 認証と認可
- 3.3.4 OAuth 2.0 / JWT

---

## 4. ソフトウェア設計原則

### 4.1 SOLID原則
- 4.1.1 単一責任の原則（SRP）
- 4.1.2 開放閉鎖の原則（OCP）
- 4.1.3 リスコフの置換原則（LSP）
- 4.1.4 インターフェース分離の原則（ISP）
- 4.1.5 依存性逆転の原則（DIP）

### 4.2 デザインパターン

#### 4.2.1 生成パターン
- Factory Pattern
- Abstract Factory Pattern
- Singleton Pattern
- Builder Pattern
- Prototype Pattern

#### 4.2.2 構造パターン
- Adapter Pattern
- Bridge Pattern
- Composite Pattern
- Decorator Pattern
- Facade Pattern
- Proxy Pattern

#### 4.2.3 振る舞いパターン
- Strategy Pattern
- Observer Pattern
- Command Pattern
- Template Method Pattern
- Iterator Pattern
- State Pattern
- Chain of Responsibility Pattern

### 4.3 アーキテクチャパターン
- 4.3.1 レイヤードアーキテクチャ
- 4.3.2 ヘキサゴナルアーキテクチャ
- 4.3.3 クリーンアーキテクチャ
- 4.3.4 マイクロサービスアーキテクチャ
- 4.3.5 イベント駆動アーキテクチャ

### 4.4 設計原則
- 4.4.1 DRY（Don't Repeat Yourself）
- 4.4.2 YAGNI（You Aren't Gonna Need It）
- 4.4.3 KISS（Keep It Simple, Stupid）
- 4.4.4 関心の分離
- 4.4.5 疎結合・高凝集

---

## 5. データベース理論

### 5.1 関係データベース理論
- 5.1.1 関係代数
- 5.1.2 正規化理論（関数従属性）
- 5.1.3 結合の種類（INNER, OUTER, CROSS）
- 5.1.4 サブクエリと相関サブクエリ

### 5.2 トランザクション理論
- 5.2.1 ACIDの詳細
- 5.2.2 分離レベルと発生する問題
- 5.2.3 2フェーズロッキング
- 5.2.4 MVCC（Multi-Version Concurrency Control）

### 5.3 分散データベース
- 5.3.1 CAP定理
- 5.3.2 BASE vs ACID
- 5.3.3 レプリケーション戦略
- 5.3.4 シャーディング

---

## 6. セキュリティ基礎

### 6.1 Webセキュリティ
- 6.1.1 SQLインジェクション
- 6.1.2 XSS（クロスサイトスクリプティング）
- 6.1.3 CSRF（クロスサイトリクエストフォージェリ）
- 6.1.4 セッションハイジャック
- 6.1.5 クリックジャッキング

### 6.2 認証・認可
- 6.2.1 認証方式（Basic, Digest, Bearer）
- 6.2.2 パスワードハッシュ化（bcrypt, Argon2）
- 6.2.3 JWT（JSON Web Token）
- 6.2.4 OAuth 2.0フロー
- 6.2.5 RBAC（ロールベースアクセス制御）

---

## 7. テスト理論

### 7.1 テスト戦略
- 7.1.1 テストピラミッド
- 7.1.2 単体テスト vs 統合テスト vs E2Eテスト
- 7.1.3 テスト駆動開発（TDD）
- 7.1.4 振る舞い駆動開発（BDD）

### 7.2 テスト技法
- 7.2.1 ホワイトボックステスト
- 7.2.2 ブラックボックステスト
- 7.2.3 境界値分析
- 7.2.4 等価分割
- 7.2.5 モックとスタブ
- 7.2.6 カバレッジの意味と限界

---

## 8. バージョン管理

### 8.1 Git基礎概念
- 8.1.1 分散バージョン管理
- 8.1.2 スナップショット vs 差分
- 8.1.3 コミット、ツリー、ブロブ
- 8.1.4 ブランチ戦略（Git Flow, GitHub Flow等）
- 8.1.5 マージ vs リベース
- 8.1.6 コンフリクト解決戦略

---

## 9. パフォーマンス最適化

### 9.1 最適化の原則
- 9.1.1 測定なくして最適化なし
- 9.1.2 ボトルネック特定手法
- 9.1.3 早すぎる最適化は悪

### 9.2 キャッシング戦略
- 9.2.1 キャッシュの種類（CPU, メモリ, ディスク, アプリ, DB）
- 9.2.2 キャッシュ無効化戦略
- 9.2.3 CDN

### 9.3 スケーラビリティ
- 9.3.1 垂直スケーリング vs 水平スケーリング
- 9.3.2 ロードバランシング
- 9.3.3 ステートレス設計

---

## 10. 開発プロセス/手法論

### 10.1 アジャイル開発
- 10.1.1 スクラムの概念（スプリント、バックログ等）
- 10.1.2 カンバン
- 10.1.3 継続的インテグレーション（CI）
- 10.1.4 継続的デリバリー（CD）

### 10.2 コード品質
- 10.2.1 リファクタリング原則
- 10.2.2 コードレビューのベストプラクティス
- 10.2.3 技術的負債
- 10.2.4 静的解析

---

## 学習優先度の目安

### 最優先（即戦力）
- セクション 4（ソフトウェア設計原則）
- セクション 6.1（Webセキュリティ）
- セクション 7（テスト理論）

### 重要（中長期）
- セクション 2（オペレーティングシステム）
- セクション 5（データベース理論）
- セクション 8（バージョン管理）

### キャリアアップ用
- セクション 1（CS基礎）
- セクション 9（パフォーマンス最適化）
- セクション 10（開発プロセス）

各概念の詳細学習ノートは、この目次を基に個別に作成していきます。
